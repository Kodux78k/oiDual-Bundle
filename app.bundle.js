
/* app.bundle.js â€” Unified Dual Infodose (Fusion HUD + Chat + Sync Patch)
   Generated by assistant. Place this file in your project and include it as <script src="/app.bundle.js"></script>
*/

/* ===== Sync Patch (keeps working even if globals load later) ===== */
(function(){
  function chatSyncOnStorage() {
    try {
      if (typeof apiKey !== 'undefined') {
        const newKey = localStorage.getItem('di_apiKey') || '';
        if (newKey && newKey !== apiKey) {
          apiKey = newKey;
          const keyEl = document.getElementById('apiKeyInput');
          if (keyEl) keyEl.value = apiKey;
        }
      }

      if (typeof modelName !== 'undefined') {
        const newModel = localStorage.getItem('di_modelName') || '';
        if (newModel && newModel !== modelName) {
          modelName = newModel;
          const mEl = document.getElementById('modelInput');
          if (mEl) mEl.value = modelName;
        }
      }

      if (typeof training !== 'undefined') {
        const t = localStorage.getItem('di_trainingText');
        if (t && training !== t) {
          training = t;
          const fname = localStorage.getItem('di_trainingFileName') || '';
          const fEl = document.getElementById('trainingFileName');
          if (fEl && fname) fEl.innerText = fname;
        }
      }

      if (typeof userName !== 'undefined')
        userName = localStorage.getItem('di_userName') || '';

      if (typeof infodoseName !== 'undefined')
        infodoseName = localStorage.getItem('di_infodoseName') || '';

      const dispU = document.getElementById('displayUser');
      const dispI = document.getElementById('displayInfodose');

      if (dispU) dispU.innerText = 'User: ' + (userName || 'â€”');
      if (dispI) dispI.innerText = 'Infodose: ' + (infodoseName || 'â€”');

    } catch (e) {
      console.warn('[Dual Sync] chatSync error', e);
    }
  }

  function cardImportDiApiKey() {
    try {
      if (typeof STATE === 'undefined' || !Array.isArray(STATE.keys)) return;
      const sk = localStorage.getItem('di_apiKey');
      const model = localStorage.getItem('di_modelName') || '';
      if (!sk) return;
      let key = STATE.keys.find(k => k.token === sk);
      if (!key) {
        STATE.keys.forEach(k => k.active = false);
        STATE.keys.unshift({
          id: 'import-' + Date.now(),
          name: 'Imported-SK',
          token: sk,
          model: model,
          webhook: '',
          active: true
        });
      } else {
        STATE.keys.forEach(k => k.active = (k.token === sk));
      }
      if (typeof saveData === 'function') saveData();
      if (typeof renderKeysList === 'function') renderKeysList();
      if (typeof updateInterface === 'function') updateInterface(STATE.user);
    } catch (e) {
      console.warn('[Dual Sync] cardImport error', e);
    }
  }

  try {
    if (typeof window.setActiveKey === 'function') {
      const original = window.setActiveKey.bind(window);
      window.setActiveKey = function(id) {
        original(id);
        try {
          const active = STATE?.keys?.find(k => k.active);
          if (active?.token) {
            localStorage.setItem('di_apiKey', active.token);
            if (active.model) localStorage.setItem('di_modelName', active.model);
          }
        } catch(e){}
      };
    }
  } catch(e){}

  window.addEventListener('storage', (e) => {
    const keys = [
      'di_apiKey',
      'di_modelName',
      'di_trainingText',
      'di_trainingFileName',
      'di_userName',
      'di_infodoseName',
      'di_assistantEnabled',
      'di_trainingActive'
    ];
    if (keys.includes(e.key)) {
      chatSyncOnStorage();
      cardImportDiApiKey();
    }
  });

  setTimeout(() => {
    chatSyncOnStorage();
    cardImportDiApiKey();
  }, 80);

})();

/* ===== Unified App (Fusion HUD + Chat) ===== */
(function(){
  // Expose globals early for the sync patch to reference
  window.apiKey = localStorage.getItem('di_apiKey') || '';
  window.modelName = localStorage.getItem('di_modelName') || 'meta-llama/llama-3.1-405b-instruct:free';
  window.userName = localStorage.getItem('di_userName') || '';
  window.infodoseName = localStorage.getItem('di_infodoseName') || '';
  window.training = '';
  window.trainingFileName = '';
  window.assistantEnabled = false;
  window.trainingActive = true;
  window.conversation = [];
  window.pages = [];
  window.currentPage = 0;
  window.autoAdvance = true;

  // DOM element references will be populated on init
  const els = {};

  // Utility functions
  const escapeHtml = s => s ? s.replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])) : '';
  function showToaster(txt,type='default'){ 
    try {
      const wrap = document.getElementById('toasterWrap') || document.body;
      const t=document.createElement('div'); t.className=`toaster ${type}`; t.innerText=txt; wrap.appendChild(t); setTimeout(()=>t.classList.add('show'),10); setTimeout(()=>{t.classList.remove('show');setTimeout(()=>t.remove(),300)},2500);
    } catch(e){ console.log('toaster',txt); }
  }

  // --- CRYPTO UTILS (AES-GCM) ---
  const CRYPTO = {
    algo: { name: 'AES-GCM', length: 256 },
    pbkdf2: { name: 'PBKDF2', hash: 'SHA-256', iterations: 100000 },
    salt: window.crypto.getRandomValues(new Uint8Array(16)),
    async getKey(password, salt) {
      const enc = new TextEncoder();
      const keyMaterial = await window.crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveKey"]);
      return window.crypto.subtle.deriveKey({ ...this.pbkdf2, salt: salt }, keyMaterial, this.algo, false, ["encrypt", "decrypt"]);
    },
    async encrypt(data, password) {
      const salt = window.crypto.getRandomValues(new Uint8Array(16));
      const iv = window.crypto.getRandomValues(new Uint8Array(12));
      const key = await this.getKey(password, salt);
      const encoded = new TextEncoder().encode(JSON.stringify(data));
      const encrypted = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, key, encoded);
      const bundle = { s: Array.from(salt), iv: Array.from(iv), d: Array.from(new Uint8Array(encrypted)) };
      return JSON.stringify(bundle);
    },
    async decrypt(bundleStr, password) {
      try {
        const bundle = JSON.parse(bundleStr);
        const salt = new Uint8Array(bundle.s);
        const iv = new Uint8Array(bundle.iv);
        const data = new Uint8Array(bundle.d);
        const key = await this.getKey(password, salt);
        const decrypted = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, data);
        return JSON.parse(new TextDecoder().decode(decrypted));
      } catch(e) { throw new Error("Senha incorreta ou dados corrompidos"); }
    }
  };

  // --- STATE & STORAGE ---
  const STORAGE_KEY = 'fusion_os_data_v2';
  const STATE = { keys: [], user: 'Convidado', isEncrypted: false, encryptedData: null };
  let SESSION_PASSWORD = null;

  // Expose STATE globally (sync patch depends on it)
  window.STATE = STATE;

  function saveData() {
    const payload = { keys: STATE.keys, user: STATE.user };
    if (SESSION_PASSWORD) {
      CRYPTO.encrypt(payload, SESSION_PASSWORD).then(enc => {
        localStorage.setItem(STORAGE_KEY, JSON.stringify({ isEncrypted: true, data: enc }));
        STATE.isEncrypted = true;
        STATE.encryptedData = enc;
        updateSecurityUI();
      });
    } else {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({ isEncrypted: false, data: payload }));
    }
  }

  async function loadData() {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    const parsed = JSON.parse(raw);
    if (parsed.isEncrypted) {
      STATE.isEncrypted = true;
      STATE.encryptedData = parsed.data;
      updateSecurityUI();
    } else {
      STATE.keys = parsed.data.keys || [];
      STATE.user = parsed.data.user || 'Convidado';
      updateInterface(STATE.user);
      renderKeysList();
    }
  }

  // --- UI Helpers (SVG avatars, hashing) ---
  const hashStr = s => { let h=0xdeadbeef; for(let i=0;i<s.length;i++){h=Math.imul(h^s.charCodeAt(i),2654435761);} return (h^h>>>16)>>>0; };
  const createSvg = (id,sz) => `<svg viewBox="0 0 100 100" width="${sz}" height="${sz}"><defs><linearGradient id="g${id}"><stop offset="0%" stop-color="#00f2ff"/><stop offset="100%" stop-color="#bd00ff"/></linearGradient></defs><circle cx="50" cy="50" r="48" fill="#080b12" stroke="rgba(255,255,255,0.1)"/><circle cx="50" cy="50" r="20" fill="url(#g${id})" opacity="0.9"/></svg>`;
  const createMiniSvg = (name,sz=30) => {
    const s = hashStr(name||'D'); const h1=s%360; const h2=(s*37)%360;
    const grad = `<linearGradient id="gm${s}" x1="0" y1="0" x2="1" y2="1"><stop offset="0" stop-color="hsl(${h1},90%,50%)"/><stop offset="1" stop-color="hsl(${h2},90%,50%)"/></linearGradient>`;
    return `<svg width="${sz}" height="${sz}" viewBox="0 0 32 32"><defs>${grad}</defs><rect width="32" height="32" rx="8" fill="#0a1016"/><circle cx="16" cy="16" r="6" fill="url(#gm${s})"/></svg>`;
  };

  // --- UI update functions (exposed) ---
  function updateInterface(name){
    const safe = name || 'Convidado';
    try {
      if (els.lblName) els.lblName.innerText = safe;
      if (els.input) els.input.value = safe;
      const activeKey = STATE.keys.find(k=>k.active);
      if (els.smallIdent) els.smallIdent.innerText = activeKey ? activeKey.name : '--';
      if (els.actBadge) els.actBadge.innerText = activeKey ? `key:${activeKey.name}` : 'v:--';
      if (els.smallMiniAvatar) els.smallMiniAvatar.innerHTML = createMiniSvg(safe);
      if (els.actMiniAvatar) els.actMiniAvatar.innerHTML = createMiniSvg(safe,36);
      if (els.actName) els.actName.innerText = safe;
      if (els.avatarTgt) els.avatarTgt.innerHTML = createSvg('Main',64);
      if (els.smallText) {
        const phrases = ["Foco estÃ¡vel.","Ritmo criativo.","PercepÃ§Ã£o sutil."];
        els.smallText.innerText = activeKey ? `${activeKey.name} [ATIVO]` : (safe==='Convidado'?'Aguardando...':`${safe} Â· ${phrases[safe.length%phrases.length]}`);
      }
      if (els.actPre) {
        const line = `+${'-'.repeat(safe.length+4)}+`;
        els.actPre.innerText = `${line}\n| ${safe.toUpperCase()} |\n${line}\nID: ${hashStr(safe).toString(16)}`;
      }
    } catch(e){}
    // sync top-info if chat is present
    try { if (typeof window.userName === 'undefined') {} else { window.userName = safe; localStorage.setItem('di_userName', safe); updateTopInfo(); } } catch(e){}
  }
  // expose
  window.updateInterface = updateInterface;

  function updateSecurityUI() {
    try {
      if (!els.securityStatus || !els.vaultStatusText || !els.lockVaultBtn) return;
      if (SESSION_PASSWORD) {
        els.securityStatus.innerText = "COFRE DESTRANCADO";
        els.securityStatus.style.color = "var(--neon-success)";
        els.vaultStatusText.innerText = "Cofre Protegido (Destrancado)";
        els.lockVaultBtn.innerText = "TRANCAR";
      } else if (STATE.isEncrypted) {
        els.securityStatus.innerText = "CRIPTOGRAFADO";
        els.securityStatus.style.color = "var(--neon-gold)";
        els.vaultStatusText.innerText = "Cofre Trancado";
        els.lockVaultBtn.innerText = "REDEFINIR";
      } else {
        els.securityStatus.innerText = "SEM PROTEÃ‡ÃƒO";
        els.securityStatus.style.color = "rgba(255,255,255,0.5)";
        els.vaultStatusText.innerText = "Cofre Aberto (Sem senha)";
        els.lockVaultBtn.innerText = "CRIAR SENHA";
      }
    } catch(e){}
  }

  // --- KEYS MANAGER LOGIC (exposed renderer) ---
  function renderKeysList(){
    try {
      if (!els.keyList) return;
      els.keyList.innerHTML = '';
      if(STATE.keys.length===0){ els.keyList.innerHTML = '<div style="color:rgba(255,255,255,0.3);text-align:center;padding:20px">Nenhuma chave armazenada.</div>'; return; }
      STATE.keys.forEach(k=>{
        const div = document.createElement('div');
        div.className = `key-item ${k.active?'active-item':''}`;
        const typeInfo = k.webhook ? '<span style="color:var(--neon-purple)">WEBHOOK</span>' : 'API KEY';
        div.innerHTML = `
          <div class="meta">
            <div style="font-weight:700;font-size:0.9rem">${escapeHtml(k.name)}</div>
            <div style="font-size:0.75rem;color:rgba(255,255,255,0.5)">${typeInfo}</div>
          </div>
          <div class="actions">
            ${!k.active ? `<button class="small-btn" data-action-activate="${k.id}">ATIVAR</button>` : `<span style="font-size:0.7rem;font-weight:700;color:var(--neon-cyan);margin-right:10px">ATIVA</span>`}
            <button class="small-btn danger" data-action-remove="${k.id}"><i data-lucide="trash-2" style="width:14px"></i></button>
          </div>
        `;
        els.keyList.appendChild(div);
      });
      if (window.lucide && lucide.createIcons) lucide.createIcons();
      // delegate events
      els.keyList.querySelectorAll('[data-action-activate]').forEach(btn=> btn.addEventListener('click', (ev)=> setActiveKey(btn.getAttribute('data-action-activate'))));
      els.keyList.querySelectorAll('[data-action-remove]').forEach(btn=> btn.addEventListener('click', (ev)=> removeKey(btn.getAttribute('data-action-remove'))));
    } catch(e){ console.warn('renderKeysList',e); }
  }
  window.renderKeysList = renderKeysList;

  function addKey() {
    try {
      const name = els.keyName.value.trim();
      const token = els.keyToken.value.trim();
      const webhook = els.keyWebhook.value.trim();
      if(!name){ showToaster('Nome obrigatÃ³rio','error'); return; }
      const newKey = { id: Date.now().toString(36), name, token, webhook, active: STATE.keys.length===0 };
      STATE.keys.push(newKey);
      saveData();
      renderKeysList();
      updateInterface(STATE.user);
      els.keyName.value=''; els.keyToken.value=''; els.keyWebhook.value='';
      showToaster('Chave adicionada!', 'success');
    } catch(e){ console.warn('addKey', e); }
  }

  function removeKey(id) {
    try {
      if(!confirm('Remover chave permanentemente?')) return;
      STATE.keys = STATE.keys.filter(k=>k.id!==id);
      saveData(); renderKeysList(); updateInterface(STATE.user);
    } catch(e){}
  }
  window.removeKey = removeKey;

  function setActiveKey(id) {
    try {
      STATE.keys.forEach(k=> k.active = (k.id===id));
      saveData(); renderKeysList(); updateInterface(STATE.user);
      showToaster('Chave ativa atualizada.', 'success');
      // sync: if active key has token, write to di_apiKey for chat module
      try {
        const active = STATE.keys.find(k=>k.active);
        if (active?.token) {
          localStorage.setItem('di_apiKey', active.token);
          if (active.model) localStorage.setItem('di_modelName', active.model);
          // update global
          window.apiKey = active.token;
          if (active.model) window.modelName = active.model;
        }
      } catch(e){}
    } catch(e){ console.warn('setActiveKey', e); }
  }
  window.setActiveKey = setActiveKey;

  // --- WEBHOOK TEST ---
  function testWebhook() {
    const url = els.keyWebhook.value.trim();
    if(!url) return showToaster('Insira uma URL', 'error');
    els.testWebhookBtn.innerHTML = '...';
    (async()=>{
      try {
        const controller = new AbortController();
        setTimeout(()=>controller.abort(), 4000);
        await fetch(url, { method: 'POST', body: JSON.stringify({ping:true}), mode: 'no-cors', signal: controller.signal });
        showToaster('Envio realizado (Ping)', 'success');
      } catch(e) {
        showToaster('Falha na conexÃ£o', 'error');
      } finally {
        els.testWebhookBtn.innerText = 'PING';
      }
    })();
  }

  // --- VAULT FLOW ---
  function openManager() {
    if (STATE.isEncrypted && !SESSION_PASSWORD) {
      if (els.vaultModal) { els.vaultModal.style.display = 'flex'; els.vaultModal.setAttribute('aria-hidden', 'false'); els.vaultPass.focus(); }
    } else {
      if (els.keysModal) { els.keysModal.style.display = 'flex'; els.keysModal.setAttribute('aria-hidden', 'false'); }
    }
  }

  async function vaultUnlock() {
    const pass = els.vaultPass.value;
    try {
      const decrypted = await CRYPTO.decrypt(STATE.encryptedData, pass);
      SESSION_PASSWORD = pass;
      STATE.keys = decrypted.keys;
      STATE.user = decrypted.user;
      if (els.vaultModal) els.vaultModal.style.display = 'none';
      if (els.keysModal) els.keysModal.style.display = 'flex';
      els.vaultPass.value = '';
      renderKeysList();
      updateSecurityUI();
      showToaster('Cofre destrancado.', 'success');
    } catch(e) {
      showToaster('Senha incorreta.', 'error');
      els.vaultPass.classList.add('vibe-gold');
      setTimeout(()=>els.vaultPass.classList.remove('vibe-gold'), 500);
    }
  }

  function lockVaultBtnHandler() {
    if (!SESSION_PASSWORD && !STATE.isEncrypted) {
      const newPass = prompt("Defina uma senha para o Cofre:");
      if(newPass) {
        SESSION_PASSWORD = newPass;
        saveData();
        showToaster("Cofre criado e trancado.", 'success');
      }
    } else {
      SESSION_PASSWORD = null;
      if (els.keysModal) els.keysModal.style.display = 'none';
      showToaster("Cofre trancado.", 'success');
    }
    updateSecurityUI();
  }

  // --- GESTURES / ORB / HUD interaction ---
  let uiState = { isOrb:false, isHud:false, isDragging:false, startX:0, startY:0, timer:null, offsetX:0, offsetY:0 };
  function handleStart(e) {
    if(!els.card) return;
    if(e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON' || e.target.closest && e.target.closest('.keys-card')) return;
    if(!uiState.isOrb && !uiState.isHud && !els.header.contains(e.target)) return;
    uiState.startX = e.clientX; uiState.startY = e.clientY; uiState.isDragging = false;
    uiState.timer = setTimeout(() => {
      if(uiState.isOrb) openManager();
      else if (!uiState.isHud) transmuteToOrb(e.clientX, e.clientY);
    }, 600);
    if(uiState.isOrb) {
       try {
         els.card.setPointerCapture(e.pointerId);
         const rect = els.card.getBoundingClientRect();
         uiState.offsetX = e.clientX - rect.left;
         uiState.offsetY = e.clientY - rect.top;
       } catch(e){}
    }
  }

  function handleMove(e) {
    if(!uiState.timer && !uiState.isOrb) return;
    const dist = Math.hypot(e.clientX - uiState.startX, e.clientY - uiState.startY);
    if(dist > 10) {
      if(uiState.timer) { clearTimeout(uiState.timer); uiState.timer = null; }
      if(uiState.isOrb) {
        uiState.isDragging = true;
        els.card.style.left = (e.clientX - uiState.offsetX) + 'px';
        els.card.style.top = (e.clientY - uiState.offsetY) + 'px';
        els.card.style.transform = 'none';
      }
    }
  }

  function handleEnd(e) {
    if(uiState.timer) { clearTimeout(uiState.timer); uiState.timer = null; }
    if(uiState.isDragging && uiState.isOrb) {
      uiState.isDragging = false; snapOrb(e.clientX, e.clientY); return;
    }
    const dist = Math.hypot(e.clientX - uiState.startX, e.clientY - uiState.startY);
    if(dist < 10) {
      if(uiState.isOrb || uiState.isHud) revertToCard();
      else toggleCardState();
    }
  }

  function transmuteToOrb(x,y) {
    if(navigator.vibrate) navigator.vibrate(50);
    els.card.classList.add('orb','closed'); els.card.classList.remove('content-visible');
    els.card.style.left=(x-34)+'px'; els.card.style.top=(y-34)+'px';
    uiState.isOrb=true; uiState.isHud=false;
  }

  function snapOrb(x,y) {
    if(y < 80) {
      uiState.isHud=true; uiState.isOrb=false; els.card.classList.add('hud'); els.card.classList.remove('orb');
      els.card.style.left=''; els.card.style.top=''; els.card.style.transform='';
    } else {
      const tx = x < window.innerWidth/2 ? 15 : window.innerWidth-83;
      els.card.style.transition='left 0.4s ease, top 0.4s ease'; els.card.style.left=tx+'px';
      setTimeout(()=>els.card.style.transition='',400);
    }
  }

  function revertToCard() {
    uiState.isOrb=false; uiState.isHud=false;
    els.card.style.transition='all 0.5s var(--ease-smooth)'; els.card.style.left=''; els.card.style.top=''; els.card.style.width=''; els.card.style.height=''; els.card.style.transform='';
    els.card.classList.remove('orb','hud','closed');
    setTimeout(()=>els.card.classList.add('content-visible'),300);
  }

  function toggleCardState() {
    if(els.card.classList.contains('animating')) return;
    const isClosed = els.card.classList.contains('closed');
    els.card.classList.add('animating');
    if(isClosed) {
      els.card.classList.remove('closed');
      els.card.animate([{transform:'scale(0.95)',opacity:0.8},{transform:'scale(1)',opacity:1}],{duration:400,easing:'cubic-bezier(0.34,1.3,0.64,1)'})
      .onfinish = ()=>{ els.card.classList.remove('animating'); els.card.classList.add('content-visible'); }
    } else {
      els.card.classList.remove('content-visible');
      els.card.animate([{transform:'translateY(0)',opacity:1},{transform:'translateY(10px)',opacity:1}],{duration:200,easing:'ease-in'})
      .onfinish = ()=>{ els.card.classList.add('closed'); els.card.classList.remove('animating'); }
    }
  }

  // --- Copy/Download helpers ---
  function copyActivationText() {
    try {
      const active = STATE.keys.find(k=>k.active);
      const append = active ? `\n\n[Active Key: ${active.name}]` : '';
      navigator.clipboard.writeText(els.actPre.innerText + append).then(()=>showToaster('Copiado!'));
    } catch(e){}
  }

  async function downloadActivationImage() {
    try {
      const canvas = await html2canvas(els.actPre, {scale:2, backgroundColor:null});
      canvas.toBlob(b=>{ const u=URL.createObjectURL(b); const a=document.createElement('a'); a.href=u; a.download='activation.png'; a.click(); });
    } catch(e){}
  }

  // --- Chat Module constants & helpers ---
  const TRAINING_FILE_FALLBACK = 'Super_Treinamento_Universal_Dual_Infodose_v1-28.txt';
  const API_ENDPOINT = 'https://openrouter.ai/api/v1/chat/completions';
  const TEMPERATURE = 0.2;
  const CRYSTAL_KEY = 'di_cristalizados';

  // Markdown renderer (depends on markdownit loaded on page)
  const md = window.markdownit ? window.markdownit({ html:false, linkify:true, typographer:true }) : { render: (t)=> (t) };

  const createEl = (tag, cls, html) => { const e = document.createElement(tag); if (cls) e.className = cls; if (html) e.innerHTML = html; return e; };
  const splitBlocks = text => {
    if (!text || !text.trim()) return [['Sem conteÃºdo de treinamento.','','']];
    let paras = text.split(/\n\s*\n/).filter(p=>p.trim());
    if (paras.length % 3 !== 0) {
      const sens = paras.join(' ').match(/[^\.!\?]+[\.!\?]+/g) || [paras.join(' ')];
      paras = sens.map(s=>s.trim());
    }
    const groups = [];
    for (let i=0;i<paras.length;i+=3) groups.push(paras.slice(i,i+3));
    return groups;
  };

  // TTS
  const speakText = (txt, onend)=> {
    if (!txt) { if (onend) onend(); return; }
    try {
      const u = new SpeechSynthesisUtterance(txt);
      u.lang = 'pt-BR'; u.rate = 0.99; u.pitch = 1.1; u.volume = 1;
      if (window._vozes) u.voice = window._vozes.find(v=>v.lang==='pt-BR') || window._vozes[0];
      if (onend) u.onend = onend;
      speechSynthesis.speak(u);
    } catch(e){}
  };

  const updateTopInfo = () => {
    try {
      const du = document.getElementById('displayUser');
      const di = document.getElementById('displayInfodose');
      if (du) du.innerText = 'User: ' + (window.userName || 'â€”');
      if (di) di.innerText = 'Infodose: ' + (window.infodoseName || 'â€”');
    } catch(e){}
  };

  const updateToggleUI = () => {
    try {
      const tb = document.getElementById('toggleBtn');
      if (tb) tb.classList.toggle('active', window.assistantEnabled);
      const as = document.getElementById('assistantActiveCheckbox');
      const tr = document.getElementById('trainingActiveCheckbox');
      if (as) as.checked = !!window.assistantEnabled;
      if (tr) tr.checked = !!window.trainingActive;
    } catch(e){}
  };

  async function loadInitialTraining() {
    try {
      const localTraining = localStorage.getItem('di_trainingText');
      const localFileName = localStorage.getItem('di_trainingFileName') || '';
      if (localTraining) {
        window.training = localTraining;
        window.trainingFileName = localFileName;
        const tf = document.getElementById('trainingFileName');
        if (tf) tf.innerText = localFileName || 'treinamento (local)';
        return;
      }
      const r = await fetch(TRAINING_FILE_FALLBACK).catch(()=>null);
      if (r && r.ok) {
        window.training = await r.text();
        window.trainingFileName = TRAINING_FILE_FALLBACK;
        const tf = document.getElementById('trainingFileName');
        if (tf) tf.innerText = TRAINING_FILE_FALLBACK;
      }
    } catch (e) { /* silent */ }
  }

  // Paginated renderer
  function renderPaginatedResponse(text) {
    try {
      speechSynthesis.cancel();
      window.autoAdvance = true;
      const respEl = document.getElementById('response');
      if (!respEl) return;
      respEl.querySelectorAll('.page:not(.initial)').forEach(p=>p.remove());
      window.pages = [];
      const groups = splitBlocks(text);
      const titles = ['ðŸŽ Recompensa Inicial','ðŸ‘ï¸ ExploraÃ§Ã£o e Curiosidade','âš¡ AntecipaÃ§Ã£o Vibracional'];
      const useSanitize = true;

      groups.forEach((tris, gi) => {
        const page = createEl('div', gi===0?'page active':'page');
        tris.forEach((body, j) => {
          const cls = j===0?'intro': j===1?'middle':'ending';
          let rendered = md.render ? md.render(body || '') : (body || '');
          if (useSanitize && window.DOMPurify) rendered = DOMPurify.sanitize(rendered);
          const b = createEl('div','response-block '+cls, `<div class="markdown-body">${rendered}</div>`);
          const meta = createEl('div','meta');
          const crystalBtn = createEl('button','crystal-btn','âœ¶');
          crystalBtn.title = 'Cristalizar essa mensagem';
          crystalBtn.addEventListener('click',(ev)=>{ ev.stopPropagation(); cristalizar({ title: titles[j], content: body }); crystalBtn.innerText='âœ“'; setTimeout(()=> crystalBtn.innerText='âœ¶',1200); });
          meta.appendChild(crystalBtn);
          b.appendChild(meta);

          const actions = createEl('div','block-actions');
          const copyBtn = createEl('button','copy-block-btn','Copiar');
          copyBtn.addEventListener('click',(ev)=>{
            ev.stopPropagation();
            navigator.clipboard.writeText(body || b.innerText).then(()=> showToaster('Bloco copiado','success'));
          });
          actions.appendChild(copyBtn);
          b.appendChild(actions);

          b.dataset.state = '';
          b.addEventListener('click', () => {
            if (!b.dataset.state) {
              speechSynthesis.cancel();
              const plain = Array.from(b.querySelectorAll('p, li')).map(n => n.innerText).join(' ');
              speakText(plain);
              b.classList.add('clicked');
              b.dataset.state = 'spoken';
            } else {
              b.classList.add('expanded');
              b.dataset.state = '';
              if (!window.assistantEnabled) {
                window.assistantEnabled = true;
                localStorage.setItem('di_assistantEnabled','1');
                if (window.training && window.trainingActive) window.conversation.unshift({ role:'system', content: window.training });
                updateToggleUI();
              }
              const blockText = `${titles[j]}\n\n${body}`;
              showLoading('Pulso em ExpansÃ£o...');
              speechSynthesis.cancel();
              speakText('Pulso em ExpansÃ£o...');
              window.conversation.push({ role:'user', content: blockText });
              callAI();
            }
          });

          b.addEventListener('animationend', e => { if (e.animationName==='clickPulse') b.classList.remove('clicked'); });

          page.appendChild(b);
        });

        page.appendChild(createEl('p','footer-text',`<em>Do seu jeito. <strong>Sempre</strong> Ãºnico. <strong>Sempre</strong> seu.</em>`));
        const controls = respEl.querySelector('.response-controls');
        if (controls) respEl.insertBefore(page, controls);
        window.pages.push(page);

        setTimeout(()=> {
          try {
            page.querySelectorAll('pre code').forEach(el => { if (window.Prism && Prism.highlightElement) Prism.highlightElement(el); });
          } catch(e) {}
        }, 40);
      });

      window.currentPage = 0;
      const pi = document.getElementById('pageIndicator');
      if (pi) pi.textContent = `1 / ${window.pages.length}`;
      speakPage(0);
    } catch(e){ console.warn('renderPaginatedResponse', e); }
  }
  window.renderPaginatedResponse = renderPaginatedResponse;

  function speakPage(i) {
    const page = window.pages[i];
    if (!page) return;
    const body = Array.from(page.querySelectorAll('.response-block p')).map(p=>p.innerText).join(' ');
    speakText(body, () => {
      if (!window.autoAdvance) return;
      if (i < window.pages.length - 1) {
        changePage(1);
        speakPage(i+1);
      } else {
        speakText('Do seu jeito, sempre Ãºnico, sempre seu.');
      }
    });
  }

  function changePage(offset) {
    const np = window.currentPage + offset;
    if (np<0||np>=window.pages.length) return;
    window.pages[window.currentPage].classList.remove('active');
    window.pages[np].classList.add('active');
    window.currentPage = np;
    const pi = document.getElementById('pageIndicator');
    if (pi) pi.textContent = `${window.currentPage+1} / ${window.pages.length}`;
  }

  function showLoading(msg) {
    const respEl = document.getElementById('response');
    if (!respEl) return;
    const controls = respEl.querySelector('.response-controls');
    respEl.querySelectorAll('.page:not(.initial)').forEach(p=>p.remove());
    const page = createEl('div','page active');
    page.appendChild(createEl('p','footer-text',msg));
    if (controls) respEl.insertBefore(page, controls);
    window.pages = [page];
    window.currentPage = 0;
    const pi = document.getElementById('pageIndicator');
    if (pi) pi.textContent = 'â€¦';
  }

  async function callAI() {
    if (!window.apiKey) {
      alert('Por favor, configure sua API Key no botÃ£o de configuraÃ§Ãµes.');
      const sModal = document.getElementById('settingsModal');
      if (sModal) sModal.classList.add('active');
      return;
    }

    const bodyObj = { model: window.modelName, messages: (window.conversation || []).slice(), temperature: TEMPERATURE };
    const messagesToSend = [];
    if (window.assistantEnabled && window.trainingActive && window.training) messagesToSend.push({ role:'system', content: window.training });
    (window.conversation || []).forEach(m => {
      if (m.role === 'system') return;
      messagesToSend.push(m);
    });
    bodyObj.messages = messagesToSend;

    try {
      const resp = await fetch(API_ENDPOINT, {
        method:'POST',
        headers:{ 'Authorization':`Bearer ${window.apiKey}`, 'Content-Type':'application/json' },
        body: JSON.stringify(bodyObj)
      });
      if (!resp.ok) throw new Error('Erro API: ' + resp.status);
      const data = await resp.json();
      const answer = (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content)
        ? data.choices[0].message.content.trim()
        : (data.result || 'Resposta vazia');
      window.conversation.push({ role:'assistant', content: answer });
      renderPaginatedResponse(answer);
    } catch (err) {
      console.error(err);
      const errorMsg = 'O pulso oscilou (Erro de ConexÃ£o ou Key invÃ¡lida). Verifique as configuraÃ§Ãµes.';
      window.conversation.push({ role:'assistant', content: errorMsg });
      renderPaginatedResponse(errorMsg);
    }
  }
  window.callAI = callAI;

  async function sendMessage(){
    const respEl = document.getElementById('response');
    const initPage = respEl ? respEl.querySelector('.page.initial') : null;
    if (initPage) initPage.remove();

    const input = document.getElementById('userInput');
    const raw = input ? input.value.trim() : '';
    if (!raw) return;
    if (input) input.value = '';

    speechSynthesis.cancel();
    speakText('');

    const txt = raw.toLowerCase();
    if (txt === 'oi dual' || txt === 'oi, dual') {
      window.assistantEnabled = true;
      localStorage.setItem('di_assistantEnabled','1');
      showLoading('Dual Infodose ativa. Pulso enviado...');
      if (window.training && window.trainingActive) window.conversation.unshift({ role:'system', content: window.training });
      updateToggleUI();
    } else {
      showLoading('âš¡Pulso enviado...Recebendo IntenÃ§Ã£oâ€¦');
    }

    window.conversation.push({ role:'user', content: raw });
    callAI();
  }
  window.sendMessage = sendMessage;

  function cristalizar({ title, content }) {
    const list = JSON.parse(localStorage.getItem(CRYSTAL_KEY) || '[]');
    const item = {
      id: Date.now(),
      title: title,
      content: content,
      user: window.userName || 'â€”',
      infodose: window.infodoseName || 'â€”',
      at: new Date().toISOString()
    };
    list.unshift(item);
    localStorage.setItem(CRYSTAL_KEY, JSON.stringify(list));
    refreshCrystalList();
  }

  function refreshCrystalList() {
    const list = JSON.parse(localStorage.getItem(CRYSTAL_KEY) || '[]');
    const el = document.getElementById('crystalList');
    if (!el) return;
    el.innerHTML = '';
    if (!list.length) {
      el.innerHTML = '<div class="small">Nenhum cristalizado ainda.</div>';
      return;
    }
    list.forEach(it => {
      const row = createEl('div','crystal-item');
      const left = createEl('div','','<strong>'+ (it.title||'â€”') +'</strong><div class="small">'+(it.infodose || '')+' Â· '+(new Date(it.at)).toLocaleString()+'</div><div style="margin-top:6px">'+ (it.content.length>220 ? it.content.slice(0,220)+'...' : it.content) +'</div>');
      const actions = createEl('div','actions');
      const copyBtn = createEl('button','btn btn-sec','Copiar');
      copyBtn.addEventListener('click', ()=> { navigator.clipboard.writeText(it.content); });
      const exportBtn = createEl('button','btn btn-prim','Exportar');
      exportBtn.addEventListener('click', ()=> {
        const blob = new Blob([it.content], { type:'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `cristal_${it.id}.txt`; a.click(); URL.revokeObjectURL(url);
      });
      const delBtn = createEl('button','btn btn-sec','Apagar');
      delBtn.addEventListener('click', () => {
        const arr = JSON.parse(localStorage.getItem(CRYSTAL_KEY) || '[]').filter(x => x.id !== it.id);
        localStorage.setItem(CRYSTAL_KEY, JSON.stringify(arr));
        refreshCrystalList();
      });
      actions.appendChild(copyBtn); actions.appendChild(exportBtn); actions.appendChild(delBtn);
      row.appendChild(left); row.appendChild(actions);
      el.appendChild(row);
    });
  }
  window.refreshCrystalList = refreshCrystalList;

  // Settings + Toggle Panel + Crystal modal setup
  function setupSettings() {
    const modal = document.getElementById('settingsModal');
    const btn = document.getElementById('settingsBtn');
    const closeBtn = document.getElementById('cancelSettings');
    const saveBtn = document.getElementById('saveSettings');
    const keyInput = document.getElementById('apiKeyInput');
    const modelInput = document.getElementById('modelInput');
    if (!btn) return;
    btn.addEventListener('click', () => {
      if (keyInput) keyInput.value = window.apiKey;
      if (modelInput) modelInput.value = window.modelName;
      if (modal) modal.classList.add('active');
    });
    const closeModal = () => modal && modal.classList.remove('active');
    if (closeBtn) closeBtn.addEventListener('click', closeModal);
    if (saveBtn) saveBtn.addEventListener('click', () => {
      if (keyInput) window.apiKey = keyInput.value.trim();
      if (modelInput) window.modelName = modelInput.value.trim() || window.modelName;
      localStorage.setItem('di_apiKey', window.apiKey);
      localStorage.setItem('di_modelName', window.modelName);
      alert('ConexÃ£o Neural Salva.');
      closeModal();
    });
    if (modal) modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
  }

  function setupTogglePanel() {
    const panel = document.getElementById('togglePanel');
    const btn = document.getElementById('toggleBtn');
    const closeBtn = document.getElementById('closePanelBtn');
    const saveBtn = document.getElementById('savePanelBtn');
    const userInput = document.getElementById('userNameInput');
    const infodoseInput = document.getElementById('infodoseNameInput');
    const assistantChk = document.getElementById('assistantActiveCheckbox');
    const trainingChk = document.getElementById('trainingActiveCheckbox');
    const fileInput = document.getElementById('trainingUpload');
    const importBtn = document.getElementById('importTrainingBtn');
    const exportBtn = document.getElementById('exportTrainingBtn');
    const trainingNameEl = document.getElementById('trainingFileName');
    if (!btn) return;
    btn.addEventListener('click', () => {
      if (userInput) userInput.value = window.userName;
      if (infodoseInput) infodoseInput.value = window.infodoseName;
      if (assistantChk) assistantChk.checked = !!window.assistantEnabled;
      if (trainingChk) trainingChk.checked = !!window.trainingActive;
      panel && panel.classList.add('active');
    });
    if (closeBtn) closeBtn.addEventListener('click', ()=> panel && panel.classList.remove('active'));
    if (saveBtn) saveBtn.addEventListener('click', () => {
      if (userInput) window.userName = userInput.value.trim();
      if (infodoseInput) window.infodoseName = infodoseInput.value.trim();
      if (assistantChk) window.assistantEnabled = !!assistantChk.checked;
      if (trainingChk) window.trainingActive = !!trainingChk.checked;
      localStorage.setItem('di_userName', window.userName);
      localStorage.setItem('di_infodoseName', window.infodoseName);
      localStorage.setItem('di_assistantEnabled', window.assistantEnabled ? '1' : '0');
      localStorage.setItem('di_trainingActive', window.trainingActive ? '1' : '0');
      updateTopInfo();
      updateToggleUI();
      panel && panel.classList.remove('active');
    });

    if (fileInput) fileInput.addEventListener('change', (e) => {
      const f = e.target.files[0];
      if (!f) return;
      window.trainingFileName = f.name;
    });

    if (importBtn) importBtn.addEventListener('click', ()=> {
      const f = fileInput.files[0];
      if (!f) { alert('Escolha um arquivo .txt para importar.'); return; }
      const r = new FileReader();
      r.onload = (ev) => {
        window.training = ev.target.result;
        window.trainingFileName = f.name || 'uploaded_training.txt';
        localStorage.setItem('di_trainingText', window.training);
        localStorage.setItem('di_trainingFileName', window.trainingFileName);
        const tf = document.getElementById('trainingFileName');
        if (tf) tf.innerText = window.trainingFileName;
        alert('Treinamento importado e salvo localmente.');
      };
      r.readAsText(f,'utf-8');
    });

    if (exportBtn) exportBtn.addEventListener('click', ()=> {
      if (!window.training) { alert('Nenhum treinamento presente para exportar.'); return; }
      const blob = new Blob([window.training], { type:'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = window.trainingFileName || 'training_export.txt'; a.click(); URL.revokeObjectURL(url);
    });
  }

  function setupCrystalModal() {
    const btn = document.getElementById('crystalBtn');
    const modal = document.getElementById('crystalModal');
    const close = document.getElementById('closeCrystal');
    const exportAll = document.getElementById('exportAllCrystal');
    const clearAll = document.getElementById('clearAllCrystal');
    if (!btn) return;
    btn.addEventListener('click', () => {
      refreshCrystalList();
      modal && modal.classList.add('active');
    });
    close && close.addEventListener('click', ()=> modal && modal.classList.remove('active'));
    exportAll && exportAll.addEventListener('click', ()=> {
      const list = JSON.parse(localStorage.getItem(CRYSTAL_KEY) || '[]');
      if (!list.length) { alert('Nada para exportar.'); return; }
      const content = list.map(it => `--- ${it.title} Â· ${it.at} Â· ${it.infodose}\n\n${it.content}\n\n`).join('\n');
      const blob = new Blob([content], { type:'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = `cristalizados_${Date.now()}.txt`; a.click(); URL.revokeObjectURL(url);
    });
    clearAll && clearAll.addEventListener('click', ()=> {
      if (!confirm('Limpar todos os cristalizados?')) return;
      localStorage.removeItem(CRYSTAL_KEY);
      refreshCrystalList();
    });
    modal && modal.addEventListener('click', (e)=> { if (e.target === modal) modal.classList.remove('active'); });
  }

  // Clipboard and small ui setup
  function setupBasicUi() {
    // send/paste/copy buttons
    const sendBtn = document.getElementById('sendBtn');
    const userInputEl = document.getElementById('userInput');
    if (sendBtn) sendBtn.addEventListener('click', sendMessage);
    if (userInputEl) userInputEl.addEventListener('keypress', e => { if (e.key==='Enter') sendMessage(); });
    const prevBtn = document.querySelector('[data-action="prev"]');
    const nextBtn = document.querySelector('[data-action="next"]');
    if (prevBtn) prevBtn.addEventListener('click', () => changePage(-1));
    if (nextBtn) nextBtn.addEventListener('click', () => changePage(1));

    const copyBtn = document.querySelector('.copy-button');
    if (copyBtn) copyBtn.addEventListener('click', () => {
      const pages = Array.from(document.querySelectorAll('.response-container .page'));
      const fullText = pages.map(p => p.innerText.trim()).join('\n\n');
      navigator.clipboard.writeText(fullText);
    });

    const pasteBtn = document.querySelector('.paste-button');
    if (pasteBtn) pasteBtn.addEventListener('click', async () => {
      try {
        const text = await navigator.clipboard.readText();
        const inp = document.getElementById('userInput');
        if (inp) inp.value = text;
      } catch (err) { console.error('Falha ao colar', err); }
    });

    // voice quick
    const voiceBtn = document.getElementById('voiceBtn');
    if (voiceBtn) voiceBtn.addEventListener('click', ()=>{
      try {
        const R = new (window.SpeechRecognition||window.webkitSpeechRecognition)();
        R.lang='pt-BR'; R.start();
        R.onresult = e => {
          const inp = document.getElementById('userInput');
          if (inp) inp.value = e.results[0][0].transcript;
          sendMessage();
        };
      } catch(e){}
    });
  }

  // Mantra mode
  function setupMantra() {
    const mantraBtn = document.getElementById('mantra-toggle');
    const mantraText = document.getElementById('mantra-text');
    if (!mantraBtn || !mantraText) return;
    let mantraCollapsed = false;
    const TXT_EXPANDED = `Do seu jeito. <strong>Sempre</strong> Ãºnico. <strong>Sempre</strong> seu.`;
    const TXT_COLLAPSED = `USE Â· TRANSFORME Â· DEVOLVA`;
    function swapMantraText(html) {
      mantraText.classList.add('fade-out');
      setTimeout(() => {
        mantraText.innerHTML = html;
        mantraText.classList.remove('fade-out');
        mantraText.classList.add('fade-in');
        setTimeout(() => mantraText.classList.remove('fade-in'), 300);
      }, 300);
    }
    mantraBtn.addEventListener('click', () => {
      mantraCollapsed = !mantraCollapsed;
      if (mantraCollapsed) {
        mantraBtn.classList.add('collapsed');
        document.body.classList.add('zen-mode');
        swapMantraText(TXT_COLLAPSED);
      } else {
        mantraBtn.classList.remove('collapsed');
        document.body.classList.remove('zen-mode');
        swapMantraText(TXT_EXPANDED);
      }
    });
  }

  // Patch: sync userName persistence
  function setupSafeUserNamePatch() {
    const safeUpdateUserName = (name) => {
      try {
        name = (name||'').toString();
        if (typeof STATE !== 'undefined') STATE.user = name || STATE.user;
        if (typeof window.userName !== 'undefined') window.userName = name || window.userName;
        localStorage.setItem('di_userName', name || '');
        try { if (typeof updateTopInfo === 'function') updateTopInfo(); } catch(e){}
      } catch(e) { console.warn('safeUpdateUserName', e); }
    };

    const inputCard = document.getElementById('inputUser');
    if (inputCard) {
      inputCard.addEventListener('change', (e) => safeUpdateUserName(e.target.value));
      inputCard.addEventListener('blur', (e) => safeUpdateUserName(e.target.value));
      if (inputCard.value && inputCard.value.trim()) safeUpdateUserName(inputCard.value.trim());
    }

    const origUpdateInterface = window.updateInterface;
    if (typeof origUpdateInterface === 'function') {
      window.updateInterface = function(name){
        try { origUpdateInterface(name); } catch(e){ console.warn(e); }
        try { safeUpdateUserName(name); } catch(e){}
      };
    }
  }

  // Initialize everything after DOM ready
  function initApp() {
    // populate els safely
    els.card = document.getElementById('mainCard');
    els.header = document.getElementById('cardHeader');
    els.avatarTgt = document.getElementById('avatarTarget');
    els.input = document.getElementById('inputUser');
    els.lblHello = document.getElementById('lblHello');
    els.lblName = document.getElementById('lblName');
    els.clock = document.getElementById('clockTime');
    els.smallPreview = document.getElementById('smallPreview');
    els.smallMiniAvatar = document.getElementById('smallMiniAvatar');
    els.smallText = document.getElementById('smallText');
    els.smallIdent = document.getElementById('smallIdent');
    els.actCard = document.getElementById('activationCard');
    els.actPre = document.getElementById('actPre');
    els.actName = document.getElementById('actName');
    els.actMiniAvatar = document.getElementById('actMiniAvatar');
    els.actBadge = document.getElementById('actBadge');
    els.securityStatus = document.getElementById('securityStatus');

    // Keys UI
    els.keysModal = document.getElementById('keysModal');
    els.keyList = document.getElementById('keyList');
    els.keyName = document.getElementById('keyNameInput');
    els.keyToken = document.getElementById('keyTokenInput');
    els.keyWebhook = document.getElementById('keyWebhookInput');
    els.addKeyBtn = document.getElementById('addKeyBtn');
    els.closeKeysBtn = document.getElementById('closeKeysBtn');
    els.testWebhookBtn = document.getElementById('testWebhookBtn');
    els.exportKeysBtn = document.getElementById('exportKeysBtn');
    els.importKeysBtn = document.getElementById('importKeysBtn');
    els.importFileInput = document.getElementById('importFileInput');
    els.lockVaultBtn = document.getElementById('lockVaultBtn');
    els.vaultStatusText = document.getElementById('vaultStatusText');

    // Vault UI
    els.vaultModal = document.getElementById('vaultModal');
    els.vaultPass = document.getElementById('vaultPassInput');
    els.vaultUnlock = document.getElementById('vaultUnlockBtn');
    els.vaultCancel = document.getElementById('vaultCancelBtn');

    // wire handlers that depend on DOM
    try { if (window.lucide && lucide.createIcons) lucide.createIcons(); } catch(e){}
    if (els.addKeyBtn) els.addKeyBtn.addEventListener('click', addKey);
    if (els.closeKeysBtn) els.closeKeysBtn.addEventListener('click', ()=> els.keysModal && (els.keysModal.style.display='none'));
    if (els.importKeysBtn) els.importKeysBtn.addEventListener('click', ()=> els.importFileInput && els.importFileInput.click());
    if (els.importFileInput) els.importFileInput.addEventListener('change', (e)=>{
       const f = e.target.files[0];
       if(f) {
         const r = new FileReader();
         r.onload = (ev) => {
           try { STATE.keys = JSON.parse(ev.target.result); saveData(); renderKeysList(); showToaster('Chaves importadas!','success'); }
           catch(e){ showToaster('Arquivo invÃ¡lido','error'); }
         };
         r.readAsText(f);
       }
    });
    if (els.testWebhookBtn) els.testWebhookBtn.addEventListener('click', testWebhook);
    if (els.vaultUnlock) els.vaultUnlock.addEventListener('click', vaultUnlock);
    if (els.lockVaultBtn) els.lockVaultBtn.addEventListener('click', lockVaultBtnHandler);
    if (els.vaultCancel) els.vaultCancel.addEventListener('click', ()=> els.vaultModal && (els.vaultModal.style.display='none'));

    // gestures
    if (els.card) els.card.addEventListener('pointerdown', handleStart);
    document.addEventListener('pointermove', handleMove);
    document.addEventListener('pointerup', handleEnd);

    // copy/download buttons
    const copyActBtn = document.getElementById('copyActBtn');
    if (copyActBtn) copyActBtn.addEventListener('click', copyActivationText);
    const downloadActBtn = document.getElementById('downloadActBtn');
    if (downloadActBtn) downloadActBtn.addEventListener('click', downloadActivationImage);

    // init visual state
    if (els.input) els.input.addEventListener('input', (e)=>{ STATE.user=e.target.value; updateInterface(e.target.value); saveData(); });
    setTimeout(()=>{ if (els.card) { els.card.classList.add('active'); if (els.avatarTgt) els.avatarTgt.classList.add('shown'); } loadData(); }, 100);
    setInterval(()=>{ if (els.clock) els.clock.innerText = new Date().toLocaleTimeString('pt-BR',{hour:'2-digit',minute:'2-digit'}); },1000);

    setupSafeUserNamePatch();
    setupSettings();
    setupTogglePanel();
    setupCrystalModal();
    setupBasicUi();
    setupMantra();

    // particles init (safe)
    try {
      if (window.particlesJS) particlesJS('particles-js',{
        particles:{ number:{value:40},color:{value:['#0ff','#f0f']}, shape:{type:'circle'},opacity:{value:0.4},size:{value:2.4}, move:{enable:true,speed:1.5} }, retina_detect:true
      });
    } catch(e){}

    // speech voices
    speechSynthesis.onvoiceschanged = () => { window._vozes = speechSynthesis.getVoices(); };

    // initial sync from localStorage to window globals
    window.apiKey = localStorage.getItem('di_apiKey') || window.apiKey;
    window.modelName = localStorage.getItem('di_modelName') || window.modelName;
    window.userName = localStorage.getItem('di_userName') || window.userName;
    window.infodoseName = localStorage.getItem('di_infodoseName') || window.infodoseName;
    window.assistantEnabled = (localStorage.getItem('di_assistantEnabled') === '1') || window.assistantEnabled;
    window.trainingActive = (localStorage.getItem('di_trainingActive') === '0') ? false : window.trainingActive;

    // bind page-level controls (if present)
    const installBtn = document.getElementById('installBtn');
    if (installBtn) {
      let deferredPrompt = null;
      window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        deferredPrompt = e;
        installBtn.style.display = 'inline-block';
      });
      installBtn.addEventListener('click', async () => {
        if (!deferredPrompt) return;
        deferredPrompt.prompt();
        const choice = await deferredPrompt.userChoice;
        if (choice && choice.outcome === 'accepted') {
          showToaster('InstalaÃ§Ã£o iniciada!', 'success');
        } else {
          showToaster('InstalaÃ§Ã£o cancelada.', 'default');
        }
        deferredPrompt = null;
        installBtn.style.display = 'none';
      });
    }

    // service worker registration helper (optional UI triggered)
    (function registerSW(){
      if (!('serviceWorker' in navigator)) return;
      try {
        navigator.serviceWorker.register('/sw.js', { scope: '/' }).then(reg => {
          if (reg.waiting) {
            // if you want: show an update button (updateBtn) and wire it to postMessage SKIP_WAITING
            const updateBtn = document.getElementById('updateBtn');
            if (updateBtn) {
              updateBtn.style.display = 'inline-block';
              updateBtn.onclick = () => {
                try {
                  const waiting = reg.waiting;
                  if (!waiting) { reg.update(); showToaster('Atualizando...', 'default'); return; }
                  waiting.postMessage({ type: 'SKIP_WAITING' });
                  updateBtn.style.display = 'none';
                  showToaster('Aplicando atualizaÃ§Ã£o...', 'default');
                } catch(e){ console.warn(e); }
              };
            }
          }
          reg.addEventListener('updatefound', () => {
            const newSW = reg.installing;
            if (!newSW) return;
            newSW.addEventListener('statechange', () => {
              if (newSW.state === 'installed') {
                if (navigator.serviceWorker.controller) {
                  const updateBtn = document.getElementById('updateBtn');
                  if (updateBtn) { updateBtn.style.display = 'inline-block'; }
                }
              }
            });
          });
          navigator.serviceWorker.addEventListener('controllerchange', () => {
            try { window.location.reload(); } catch(e){}
          });
        }).catch(e=>console.warn('SW reg fail',e));
      } catch(e){}
    })();

  } // end initApp

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initApp);
  else initApp();

})(); // end unified bundle
